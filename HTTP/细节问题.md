DNS 解析:将域名解析成 IP 地址
TCP 连接：TCP 三次握手
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
断开连接：TCP 四次挥手

### DNS 域名解析

    1. 在浏览器DNS缓存中去找
    2. 没有则在系统本地的hosts文件去找IP地址映射
    3. 没有在hosts里找到映射，查找本地DNS解析器缓存
    4. 如果没有则就去根域名服务器查找

### URL(Uniform Resource Locator)

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。
比如 http://www.w3school.com.cn/html/index.asp，
遵守以下的语法规则：
scheme://host.domain:port/path/filename
各部分解释如下：
scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host - 定义域主机（http 的默认主机是 www.[www 可有可无原因](https://www.jb51.net/yunying/483942.html)）
domain - 定义因特网域名，比如 w3school.com.cn
port - 定义主机上的端口号（http 的默认端口号是 80）
path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename - 定义文档/资源的名称

### DNS 域名解析

- IP （IP Address）127.0.0.1 为本机 IP，不利于人类的记忆习惯。但对于计算机来说，更擅长处理一长串数字。为此，DNS 服务器产生。

- 解析流程

      浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
      操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
      路由缓存：路由器也有 DNS 缓存。
      ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
      根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，
      然后再问.baidu 域名服务器，依次类推）

##### 迭代查询

- 本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。

##### 递归查询

- 本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 DNS 客户机的身份向其它域名服务器查询，直到得到最终的 IP 地址告诉本机

### TCP 三次握手

**在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。**

1. 握手过程

第一次： **client => server** SYN=1,Seq=X。发送数据到服务端
第二次： **server => client** SYN=1,ACK=X+1,Seq=Y。传达确认信息。
第三次： **client => server** ACK=Y+1,Seq=Z。回传信息，代表握手结束。

2. 为啥需要三次握手(重点！！！！)

**谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。**

**本质上三次握手不是 TCP 的要求，而是为了满足在信道不可靠的情况下，确认数据传输是可靠的，而三次通信连接是理论上的最小值。**

**三次握手是为了保证 serve、client 端都有接受和发送数据的能力。**

### 四次挥手

ACK、Seq、Fin 数据包

- 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(**第一次挥手：由浏览器发起的，发送给服务器**，我请求报文发送完了，你准备关闭吧)
- 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(**第二次挥手：由服务器发起的，告诉浏览器**，我请求报文接受完了，我准备关闭了，你也准备吧)
- 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(**第三次挥手：由服务器发起，告诉浏览器**，我响应报文发送完了，你准备关闭吧)
- 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：**由浏览器发起，告诉服务器**，我响应报文接受完了，我准备关闭了，你也准备吧)

#### 为什么挥手是四次

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
而关闭连接时，**服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了**，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

#### 连接建立了，但客户端故障怎么办

**TCP 还设有一个保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，**时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 分钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。**

### 发送 HTTP 请求

请求行： GET /index.html HTTP1.1，包括请求方法，请求地址等
请求头： Request Headers，请求头部通知服务器有关于客户端请求的信息，比如 Host,Connection: keep-alive 持久连接等,User-agent 等。
请求体： 请求携带的参数，name=tom&password=1234&realName=tomson，携带了 name.password.realName 参数

### 服务器处理请求并返回 HTTP 报文

常见的 web server 有 apache、nginx 等。

- 响应报文

  1. 响应行: 包含协议版本、状态码等
  2. 响应头部: 响应报文的附加信息，key/value 对组成
  3. 响应主体: 返回响应数据，并不是所有响应报文都有响应数据

### GET 和 POST 请求区别

GET 在浏览器回退时是无害的，而 POST 会再次提交请求。

GET 产生的 URL 地址可以被添加书签，而 POST 不可以。

GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。

GET 请求只能进行 url 编码，而 POST 支持多种编码方式。

GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。

GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。

对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。

GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。

GET 参数通过 URL 传递，POST 放在 Request body 中。

**对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）**
**GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包**
